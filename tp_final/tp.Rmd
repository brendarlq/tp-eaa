---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code.

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*.

```{r}
install.packages("openxlsx")
# Instalar el paquete si no está instalado
if (!require("dplyr")) install.packages("dplyr")
# Cargar el paquete
library(dplyr)
```

# Trabajo Práctico Final

# 1) Fuente de datos

## Carga el dataset

.

```{r}
library(openxlsx)
delitos <- read.xlsx("/Users/bquinonez/Downloads/delitos_2023.xlsx")
delitos
```

```{r}
summary(delitos)

```

```{r}
dim(delitos)
```

# 2) Preprocesamiento

## Verificación de nulos

```{r}
colSums(is.na(delitos))
```

Tipos de Delitos

```{r}
cantidad_valores_unicos <- (unique(delitos$tipo))
print(cantidad_valores_unicos)
```

Subtipos de delitos

```{r}
conteo_por_tipo <- table(delitos$tipo)
print(conteo_por_tipo)
```

```{r}
cantidad_valores_unicos <- (unique(delitos$subtipo))
print(cantidad_valores_unicos)
conteo_por_subtipo <- table(delitos$subtipo)
print(conteo_por_subtipo)
```

## Creación de variables

Agregamos la columna de franja horaria

```{r}
#Genero la columna franja(horaria)
delitos <- delitos %>%
  mutate(
    franja_horaria = case_when(
      franja >= 6 & franja < 12 ~ "Mañana",
      franja >= 12 & franja < 18 ~ "Tarde",
      franja >= 18 & franja < 24 ~ "Noche",
      franja >= 0 & franja < 6  ~ "Madrugada",
      TRUE ~ "Desconocido" # Para casos fuera de rango 
    )
  )
delitos
```

Agregamos una columna que indica si es fin de semana o día de semana

```{r}
delitos$tipo_dia <- ifelse(delitos$dia %in% c("SAB", "DOM"),
                                             "Fin de semana", "Día de semana")
delitos
```

Agregamos una columna que indica la estación del año

```{r}
# Crear columna 'estacion' basada en el mes
delitos <- delitos %>%
  mutate(
    estacion = case_when(
      mes %in% c("diciembre", "enero", "febrero") ~ "Verano",
      mes %in% c("marzo", "abril", "mayo")       ~ "Otoño",
      mes %in% c("junio", "julio", "agosto")     ~ "Invierno",
      mes %in% c("septiembre", "octubre", "noviembre") ~ "Primavera",
      TRUE ~ "Desconocido" # Para casos no esperados
    )
  )
delitos
```

## Transformación de variables categóricas

Transformamos todos los caracteres a numéricos

```{r}

# Convertir todas las variables categóricas (character o factor) a numéricas
delitos <- delitos %>%
  mutate(across(
    .cols = where(is.character) & !all_of(c("longitud", "latitud")), 
    .fns = ~ as.numeric(as.factor(.))
  )) %>%
  mutate(across(
    .cols = where(is.factor) & !all_of(c("longitud", "latitud")), 
    .fns = ~ as.numeric(.)
  ))

# Verificar la estructura después de la conversión
delitos

```

Conversión de coordenas a númericas

```{r}
# Convertir longitud y latitud a numéricas y escalarlas correctamente
delitos <- delitos %>%
  mutate(
    longitud = as.numeric(longitud) / 1e6,  # Escalar dividiendo entre 10^6
    latitud = as.numeric(latitud) / 1e6    # Escalar dividiendo entre 10^6
  )

# Verificar las primeras filas para confirmar
head(delitos[c("longitud", "latitud")])
```

Eliminación de Nulos (Pero tiene que ser transformación de nulos para no perder datos, lo hacemos después)

```{r}
delitos <- na.omit(delitos)
dim(delitos)

delitos <- delitos %>% 
  filter(barrio != "0")
```

# 3) Aplicación de FDA

## Hacemos la agrupación correspondiente por las variables que vamos a usar.
```{r}
# Cargar librerías necesarias
library(dplyr)
library(tidyr)
library(fda.usc)
library(fda)
library(ggplot2)
library(ggrepel)
library(tibble)  # Para usar column_to_rownames

# Paso 1: Agrupar datos y preparar la matriz funcional
# Agrupar por barrio y fecha, sumando la frecuencia de delitos
delitos_agrupados_barrio <- delitos %>%
  group_by(barrio, fecha) %>%
  summarise(frecuencia_diaria = sum(cantidad, na.rm = TRUE), .groups = "drop")

# Crear matriz funcional: barrios como filas, fechas como columnas
delitos_matrix <- delitos_agrupados_barrio %>%
  pivot_wider(names_from = fecha, values_from = frecuencia_diaria, values_fill = 0) %>%
  column_to_rownames(var = "barrio") %>%
  as.matrix()

# Eliminar filas con valores faltantes y verificar la variabilidad
delitos_matrix <- delitos_matrix[complete.cases(delitos_matrix), ]
variabilidad <- apply(delitos_matrix, 1, var, na.rm = TRUE)
delitos_matrix <- delitos_matrix[variabilidad > 0.01, ]

# Asegurarse de que la matriz tiene suficientes filas para clustering
if (nrow(delitos_matrix) < 3) {
  stop("No hay suficientes barrios con datos válidos para realizar clustering.")
}

# Paso 2: Representar Datos como Curvas Funcionales con Suavizado
# Crear una base B-spline penalizada para suavizar las funciones
num_puntos <- ncol(delitos_matrix)
rang <- c(1, num_puntos)  # Rango de las fechas representadas
nbasis <- 20  # Ajusta el número de bases para mayor flexibilidad
lambda <- 1e-2  # Parámetro de suavizado; menor valor = más suave

# Crear la base B-spline
basis <- create.bspline.basis(rang, nbasis = nbasis)

# Definir el objeto de parámetros funcionales con suavizado
fd_par <- fdPar(basis, Lfdobj = int2Lfd(2), lambda = lambda)

# Convertir las filas de la matriz en funciones continuas suavizadas
fd_obj_suavizado <- smooth.basis(seq(rang[1], rang[2]), t(delitos_matrix), fd_par)$fd

# Visualizar las funciones suavizadas por barrio antes del clustering
colores <- rainbow(nrow(delitos_matrix))  # Generar colores únicos para cada barrio
plot(fd_obj_suavizado, main = "Funciones Suavizadas por Barrio (Antes del Clustering)",
     xlab = "Fecha (Índice)", ylab = "Frecuencia", col = colores, lwd = 1.5)

# Agregar una leyenda para identificar los barrios
legend("topright", legend = rownames(delitos_matrix), col = colores, lty = 1, cex = 0.5, ncol = 2)


# Paso 3: Clustering Funcional con K-Means
# Determinar el número óptimo de clusters con el método del codo
set.seed(123)
wss <- sapply(2:10, function(k) {
  kmeans(fd_obj_suavizado$coefs, centers = k, nstart = 20)$tot.withinss
})

# Graficar el método del codo
plot(2:10, wss, type = "b", pch = 19, frame = FALSE,
     xlab = "Número de Clusters", ylab = "Suma de Errores al Cuadrado (WSS)",
     main = "Método del Codo para Clustering Funcional")

# Elegir un número de clusters (por ejemplo, 3)
num_clusters <- 3
kmeans_result <- kmeans(fd_obj_suavizado$coefs, centers = num_clusters, nstart = 20)

```

```{r}

# Validar que no haya valores faltantes en delitos_matrix
if (any(is.na(delitos_matrix))) {
  stop("Hay valores faltantes en 'delitos_matrix' después de la preparación.")
}

# Validar la variabilidad de las filas
variabilidad <- apply(delitos_matrix, 1, var, na.rm = TRUE)
if (any(variabilidad == 0)) {
  warning("Se eliminarán filas con variabilidad cero en 'delitos_matrix'.")
  delitos_matrix <- delitos_matrix[variabilidad > 0, ]
}

# Aplicar kmeans funcional con manejo de clusters pequeños
set.seed(123)
num_clusters <- 3  # Cambiar según necesidad

kmeans_result = kmeans.fd(fd_obj_suavizado, ncl = num_clusters, min.cluster.size = 3)
  
# Asignar clusters a los barrios
clusters <- data.frame(
  barrio = rownames(delitos_matrix),
  cluster = kmeans_result$cluster
)

# Visualización de Clusters
df_curves <- as.data.frame(t(eval.fd(seq(rang[1], rang[2]), fd_obj_suavizado))) %>%
  rownames_to_column("barrio") %>%
  pivot_longer(-barrio, names_to = "fecha", values_to = "frecuencia") %>%
  mutate(cluster = factor(clusters$cluster[match(barrio, clusters$barrio)]))

ggplot(df_curves, aes(x = as.numeric(fecha), y = frecuencia, group = barrio, color = cluster)) +
  geom_line(alpha = 0.7) +
  theme_minimal() +
  labs(title = "Clustering Funcional por Barrio", x = "Fecha (Índice)", y = "Frecuencia", color = "Cluster") +
  theme(legend.position = "bottom")

# Añadir tamaño de cluster al gráfico
cluster_sizes <- table(clusters$cluster)
ggplot(df_curves, aes(x = as.numeric(fecha), y = frecuencia, group = barrio, color = cluster)) +
  geom_line(alpha = 0.7) +
  theme_minimal() +
  labs(
    title = "Clustering Funcional por Barrio",
    x = "Fecha (Índice)",
    y = "Frecuencia",
    color = "Cluster"
  ) +
  theme(legend.position = "bottom") +
  scale_color_discrete(labels = paste0("Cluster ", names(cluster_sizes), " (n=", cluster_sizes, ")"))


```

## Creamos la variable indendiente y las matrices correspondientes

```{r}
# Crear la respuesta (frecuencia de delitos por día)
Y <- delitos_frecuencia$frecuencia

# Crear una matriz funcional para 'tipo'
# n_puntos <- 10  # Número de puntos funcionales
# tipo_matrix <- matrix(rep(delitos_agrupados$tipo_promedio, each = n_puntos), 
#                      nrow = nrow(delitos_agrupados), 
#                      ncol = n_puntos)

# Crear una matriz funcional para 'franja_horaria'
# franja_horaria_matrix <- matrix(rep(delitos_agrupados$franja_horaria_promedio, each = n_puntos), 
#                                nrow = nrow(delitos_agrupados), 
#                                ncol = n_puntos)

# Verificar dimensiones
print(length(Y))  # Longitud de Y
print(dim(franja_horaria_matrix))  # Dimensiones de tipo_matrix

n_fechas <- length(unique(delitos$fecha))
n_franjas <- length(unique(delitos$franja))

cat("Dimensiones esperadas de franja_horaria_matrix:", n_fechas, "x", n_franjas, "\n")
cat("Dimensiones reales:", dim(franja_horaria_matrix), "\n")


```

## Creamos el modelo con tipo de delito

```{r}
# Ajustar el modelo funcional con 'tipo' como predictora funcional
modelo_refund_tipo <- pfr(
  Y ~ lf(franja_horaria_matrix, bs = "ps"),  # lf() para predictoras funcionales
  data = delitos_agrupados
)

# Resumen del modelo
summary(modelo_refund_tipo)

# Visualizar el efecto funcional
plot(modelo_refund_tipo, main = "Efecto Funcional de Franja", 
     xlab = "Dominio (Puntos Funcionales)", ylab = "Efecto")



```
# Creamos el modelo mixto con tipo y franja horaria

```{r}
# Ajustar un modelo funcional con múltiples predictoras funcionales
modelo_refund_mixto <- pfr(
  Y ~ lf(tipo_delito_matrix, bs = "ps") + lf(franja_horaria_matrix, bs = "ps"),
  data = delitos_agrupados
)

# Resumen del modelo mixto
summary(modelo_refund_mixto)

# Visualizar los efectos funcionales de las predictoras
plot(modelo_refund_mixto, main = "Efectos Funcionales de las Predictoras", pages = 1)


```


# Calculamos las métricas de la predicción
```{r}
# Generar predicciones del modelo mixto
# Predicciones del modelo
predicciones <- predict(modelo_refund_mixto)

# Valores reales (frecuencia de delitos)
valores_reales <- Y

# Calcular MAE
mae <- mean(abs(valores_reales - predicciones))

# Calcular MSE
mse <- mean((valores_reales - predicciones)^2)

# Calcular RMSE
rmse <- sqrt(mse)

# Calcular R^2
sse <- sum((valores_reales - predicciones)^2)  # Suma de errores al cuadrado
sst <- sum((valores_reales - mean(valores_reales))^2)  # Suma total de cuadrados
r2 <- 1 - (sse / sst)

# Mostrar las métricas
cat("MAE:", mae, "\n")
cat("MSE:", mse, "\n")
cat("RMSE:", rmse, "\n")
cat("R^2:", r2, "\n")

# Graficar predicciones vs valores reales
plot(Y, predicciones, main = "Predicciones vs Valores Reales (Modelo Mixto)",
     xlab = "Valores Reales", ylab = "Predicciones", col = "blue")
abline(0, 1, col = "red")

```


