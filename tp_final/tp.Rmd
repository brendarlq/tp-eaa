---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code.

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*.

```{r}
install.packages("openxlsx")
# Instalar el paquete si no est치 instalado
if (!require("dplyr")) install.packages("dplyr")
# Cargar el paquete
library(dplyr)
```

# Trabajo Pr치ctico Final

# 1) Fuente de datos

## Carga el dataset

.

```{r}
library(openxlsx)
delitos <- read.xlsx("/Users/maria/Downloads/delitos_2023.xlsx")
delitos
```

```{r}
summary(delitos)

```

```{r}
dim(delitos)
```

# 2) Preprocesamiento

## Verificaci칩n de nulos

```{r}
colSums(is.na(delitos))
```

Tipos de Delitos

```{r}
cantidad_valores_unicos <- (unique(delitos$tipo))
print(cantidad_valores_unicos)
```

Subtipos de delitos

```{r}
conteo_por_tipo <- table(delitos$tipo)
print(conteo_por_tipo)
```
```{r}
library(ggplot2)
library(dplyr)

# Agrupar los datos
delitos_agrupados <- delitos %>%
  group_by(mes, tipo, subtipo) %>%
  summarise(total = n(), .groups = "drop") %>%
  mutate(
    subtipo = factor(subtipo, levels = unique(subtipo))  # Mantener el orden original
  )

# Crear el gr치fico sin n칰meros
grafico_apilado <- ggplot(delitos_agrupados, aes(x = mes, y = total, fill = subtipo)) +
  geom_bar(stat = "identity", position = "stack") +
  facet_wrap(~ tipo, scales = "free_y") +  # Dividir por tipo de delito
  labs(
    title = "Distribuci칩n de Subtipos de Delitos por Tipo y Mes",
    x = "Mes",
    y = "N칰mero de Delitos",
    fill = "Subtipo de Delito"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "bottom",
    strip.text = element_text(size = 12),  # Tama침o del t칤tulo de cada faceta
    plot.title = element_text(hjust = 0.5),  # Centrar el t칤tulo
    legend.text = element_text(size = 10),  # Ajustar tama침o de texto de la leyenda
    legend.key.size = unit(0.8, "cm")  # Tama침o de las cajas de la leyenda
  ) +
  scale_fill_brewer(palette = "Set3")  # Paleta de colores diferenciados

# Mostrar el gr치fico
print(grafico_apilado)



delitos_agrupados2 <- delitos %>%
  group_by( tipo, subtipo) %>%
  summarise(total = n(), .groups = "drop")

delitos_agrupados2
delitos_agrupados

```


```{r}
library(ggplot2)
library(dplyr)

# Agrupar los datos por franja horaria, tipo y subtipo
delitos_agrupados_horario <- delitos %>%
  group_by(franja, tipo, subtipo) %>%
  summarise(total = n(), .groups = "drop") %>%
  mutate(
    subtipo = factor(subtipo, levels = unique(subtipo))  # Mantener el orden original
  )

# Crear el gr치fico apilado por franja horaria
grafico_horarios <- ggplot(delitos_agrupados_horario, aes(x = franja, y = total, fill = subtipo)) +
  geom_bar(stat = "identity", position = "stack") +
  facet_wrap(~ tipo, scales = "free_y") +  # Dividir por tipo de delito
  labs(
    title = "Distribuci칩n de Subtipos de Delitos por Tipo y Franja Horaria",
    x = "Franja Horaria",
    y = "N칰mero de Delitos",
    fill = "Subtipo de Delito"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "bottom",
    strip.text = element_text(size = 12),  # Tama침o del t칤tulo de cada faceta
    plot.title = element_text(hjust = 0.5),  # Centrar el t칤tulo
    legend.text = element_text(size = 10),  # Ajustar tama침o de texto de la leyenda
    legend.key.size = unit(0.8, "cm")  # Tama침o de las cajas de la leyenda
  ) +
  scale_fill_brewer(palette = "Set3")  # Paleta de colores diferenciados

# Mostrar el gr치fico
print(grafico_horarios)

```
```{r}
library(ggplot2)
library(dplyr)

# Agrupar los datos por franja horaria
delitos_por_hora <- delitos %>%
  group_by(franja) %>%
  summarise(total = n(), .groups = "drop")

# Crear el gr치fico de barras
grafico_horas <- ggplot(delitos_por_hora, aes(x = franja, y = total)) +
  geom_bar(stat = "identity", fill = "steelblue", color = "black", width = 0.7) +
  labs(
    title = "Distribuci칩n de Delitos por Hora",
    x = "Hora del D칤a",
    y = "N칰mero de Delitos"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.title = element_text(hjust = 0.5),
    panel.grid.major = element_line(size = 0.5, linetype = "dotted"),
    panel.grid.minor = element_blank()
  )

# Mostrar el gr치fico
print(grafico_horas)

```


          




```{r}
cantidad_valores_unicos <- (unique(delitos$subtipo))
print(cantidad_valores_unicos)
conteo_por_subtipo <- table(delitos$subtipo)
print(conteo_por_subtipo)
```

## Creaci칩n de variables

Agregamos la columna de franja horaria

```{r}
#Genero la columna franja(horaria)
delitos <- delitos %>%
  mutate(
    franja_horaria = case_when(
      franja >= 6 & franja < 12 ~ "Ma침ana",
      franja >= 12 & franja < 18 ~ "Tarde",
      franja >= 18 & franja < 24 ~ "Noche",
      franja >= 0 & franja < 6  ~ "Madrugada",
      TRUE ~ "Desconocido" # Para casos fuera de rango 
    )
  )
delitos
```

Agregamos una columna que indica si es fin de semana o d칤a de semana

```{r}
delitos$tipo_dia <- ifelse(delitos$dia %in% c("SAB", "DOM"),
                                             "Fin de semana", "D칤a de semana")
delitos
```

Agregamos una columna que indica la estaci칩n del a침o

```{r}
# Crear columna 'estacion' basada en el mes
delitos <- delitos %>%
  mutate(
    estacion = case_when(
      mes %in% c("diciembre", "enero", "febrero") ~ "Verano",
      mes %in% c("marzo", "abril", "mayo")       ~ "Oto침o",
      mes %in% c("junio", "julio", "agosto")     ~ "Invierno",
      mes %in% c("septiembre", "octubre", "noviembre") ~ "Primavera",
      TRUE ~ "Desconocido" # Para casos no esperados
    )
  )
delitos
```

## Transformaci칩n de variables categ칩ricas

Transformamos todos los caracteres a num칠ricos, arreglo para no sobreescribir, exceptuando moto,arma,lat,long

```{r}
library(dplyr)

# Convertir columnas espec칤ficas `uso_arma` y `uso_moto` (S칤=1, No=0)
del <- delitos %>%
  mutate(
    uso_arma = ifelse(uso_arma == "SI", 1, 0),
    uso_moto = ifelse(uso_moto == "SI", 1, 0)
  )

# Convertir otras columnas categ칩ricas a nuevas columnas codificadas
del <- del %>%
  mutate(across(
    .cols = where(is.character) & !all_of(c("longitud", "latitud", "uso_arma", "uso_moto")), 
    .fns = ~ as.numeric(as.factor(.)),
    .names = "{.col}_cod"
  )) %>%
  mutate(across(
    .cols = where(is.factor) & !all_of(c("longitud", "latitud", "uso_arma", "uso_moto")), 
    .fns = ~ as.numeric(.),
    .names = "{.col}_cod"
  ))

# Verificar la estructura del dataset despu칠s de las transformaciones
str(del)

```




##Conversi칩n de coordenas a n칰mericas

```{r}
# Convertir longitud y latitud a num칠ricas y escalarlas correctamente
delitos <- delitos %>%
  mutate(
    longitud = as.numeric(longitud) / 1e6,  # Escalar dividiendo entre 10^6
    latitud = as.numeric(latitud) / 1e6    # Escalar dividiendo entre 10^6
  )

# Verificar las primeras filas para confirmar
head(delitos[c("longitud", "latitud")])
```
```{r}
library(ggplot2)
library(dplyr)

# Agrupaci칩n por a침o, mes y tipo de delito
delitos_temporal <- del %>%
  group_by(anio, mes_cod, tipo) %>%
  summarise(total_delitos = n(), .groups = "drop")

# Visualizaci칩n de la evoluci칩n
ggplot(delitos_temporal, aes(x = mes_cod, y = total_delitos, color = tipo, group = tipo)) +
  geom_line(size = 1) +
  scale_x_continuous(breaks = 1:12, labels = month.abb) +
  labs(title = "Evoluci칩n Temporal de Delitos por Tipo",
       x = "Mes",
       y = "N칰mero de Delitos",
       color = "Tipo de Delito") +
  theme_minimal()

```

```{r}
delitos_temporal_h <- del %>%
  group_by(franja, tipo) %>%
  summarise(total_delitos = n(), .groups = "drop")

delitos_temporal_h$franja <- as.character(delitos_temporal_h$franja)


ggplot(delitos_temporal_h, aes(x = franja, y = total_delitos, color = tipo, group = tipo)) +
  geom_line(size = 1) +
  labs(title = "Evoluci칩n Temporal de Delitos por Tipo",
       x = "Franja Horaria",
       y = "N칰mero de Delitos",
       color = "Tipo de Delito") +
  theme_minimal()


```



Eliminaci칩n de Nulos

```{r}
delitos <- na.omit(delitos)
dim(delitos)
```
```{r}
library(ggplot2)
library(dplyr)

# Agrupar los datos por barrio y tipo de delito
delitos_por_barrio <- delitos %>%
  group_by(barrio, tipo) %>%
  summarise(total = n(), .groups = "drop") %>%
  group_by(barrio) %>%
  mutate(total_barrio = sum(total)) %>%
  ungroup() %>%
  mutate(barrio = reorder(barrio, -total_barrio))

# Filtrar los 15 barrios con m치s delitos
top_barrios <- delitos_por_barrio %>%
  filter(barrio %in% unique(barrio)[1:15])

# Crear el gr치fico de barras apiladas
ggplot(top_barrios, aes(x = barrio, y = total, fill = tipo)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(
    title = "Frecuencia de Delitos por Barrio y Tipo (Top 15)",
    x = "Barrio",
    y = "N칰mero de Delitos",
    fill = "Tipo de Delito"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),  # Rotar etiquetas a 90 grados
    plot.title = element_text(hjust = 0.5)  # Centrar el t칤tulo
  )

# Guardar el gr치fico con dimensiones mayores
ggsave("grafico_delitos_barrio.png", width = 12, height = 8, dpi = 300)


```
## Dia de semana vs Finde
```{r}
# Agrupar los datos por d칤a de la semana
delitos_por_dia <- delitos %>%
  group_by(tipo_dia) %>%
  summarise(total = n(), .groups = "drop")

# Crear el gr치fico de barras
ggplot(delitos_por_dia, aes(x = tipo_dia, y = total, fill = tipo_dia)) +
  geom_bar(stat = "identity", width = 0.7) +
  labs(
    title = "Frecuencia de Delitos por D칤a de la Semana",
    x = "D칤a de la Semana",
    y = "N칰mero de Delitos"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5),  # Centrar el t칤tulo
    axis.text.x = element_text(angle = 45, hjust = 1)  # Rotar etiquetas si es necesario
  ) +
  scale_fill_brewer(palette = "Set3")  # Paleta de colores


```

```{r}
# Agrupar los datos por estaci칩n
delitos_por_estacion <- delitos %>%
  group_by(estacion) %>%
  summarise(total = n(), .groups = "drop")

# Crear el gr치fico de barras
ggplot(delitos_por_estacion, aes(x = estacion, y = total, fill = estacion)) +
  geom_bar(stat = "identity") +
  labs(
    title = "Frecuencia de Delitos por Estaci칩n del A침o",
    x = "Estaci칩n",
    y = "N칰mero de Delitos"
  ) +
  theme_minimal()

```

No hay casos de moto,y uso de arma
```{r}

conteo_arma <- table(delitos$uso_arma)
conteo_moto <- table(delitos$uso_moto)

conteo_arma
conteo_moto

```




<br>

# 3) Aplicaci칩n de FDA

1) Frecuencia de delitos agrupodos por fecha
2) Frencuencia de delitos agrupados por franja
3) Frencuencia de delitos agrupados por franja y fecha (24)
4) Frecuencia de delitos por d칤a de la semana (7)
5) Frecuencia de delitos agrupodos por fecha para cada barrio
6) Frecuencia de delitos agrupados por fecha por tipo de delito
7) Frecuenda de delitos agrupados por franja horaria (Ma침ana, Tarde, Noche, Madrugada)
<br>

## Frecuencia de delitos agrupado por fecha

```{r}
library(dplyr)

# Agrupar por fecha y calcular la frecuencia diaria de delitos
frecuencia_delitos_por_dia <- delitos %>%
  group_by(fecha) %>%  # Agrupar por fecha
  summarise(frecuencia = n())  # Contar los delitos

# Aseg칰rate de que las fechas est칠n en formato Date
frecuencia_delitos_por_dia$fecha <- as.Date(frecuencia_delitos_por_dia$fecha, origin = "1899-12-30")

```


```{r}
library(fda)

# Definir el rango de las fechas
range_dias <- c(min(frecuencia_delitos_por_dia$fecha), max(frecuencia_delitos_por_dia$fecha))

# Crear la base de B-splines
n_basis <- 25  # N칰mero de funciones base
basis <- create.bspline.basis(rangeval = as.numeric(range_dias), nbasis = n_basis)


```

```{r}
# Convertir las fechas a formato num칠rico
fechas_numericas <- as.numeric(frecuencia_delitos_por_dia$fecha)

# Crear el objeto funcional
frecuencia_fd <- Data2fd(
  argvals = fechas_numericas,  # Fechas como variable independiente
  y = frecuencia_delitos_por_dia$frecuencia,  # Frecuencia como variable dependiente
  basisobj = basis
)

```

Frecuencia de delitos a lo largo del tiempo
```{r}
# Graficar la curva funcional
plot(frecuencia_fd, 
     main = "Frecuencia de Delitos a lo Largo del Tiempo", 
      
     ylab = "Frecuencia de Delitos" ,
     xaxt = "n") # Evita dibujar el eje X autom치ticamente

# Personalizar las etiquetas del eje X para mostrar fechas legibles
fechas_legibles <- frecuencia_delitos_por_dia$fecha # Aseg칰rate de que esta columna sea de clase Date o POSIXct
axis.Date(1, at = fechas_legibles, format = "%Y-%m-%d", las = 2, cex.axis = 0.7)


```


# Frecuencia de delitos agrupado por horario

(Hacer)

```{r}
# Agrupar por d칤a y horario, y contar la frecuencia de delitos
delitos_por_dia <- delitos %>%
  group_by(fecha) %>%  # 'franja_horaria' representa los horarios
  summarise(frecuencia = n(), .groups = "drop")

# Aseg칰rate de que las fechas est칠n en formato Date
delitos_por_dia$fecha <- as.Date(delitos_por_dia$fecha, origin = "1899-12-30")
summary(delitos_por_dia)
```
```{r}
library(dplyr)
library(tidyr)
library(tibble)
delitos_por_fecha <- delitos %>%
  group_by(fecha) %>%
  summarise(frecuencia = n(), .groups = "drop")

# Aseg칰rate de que las fechas est칠n en formato Date
delitos_por_fecha$fecha <- as.Date(delitos_por_fecha$fecha, origin = "1899-12-30")

# Crear la matriz
matriz_frecuencia <- delitos_por_fecha %>%
  column_to_rownames(var = "fecha") %>%
  as.matrix()

rownames(matriz_frecuencia)  # Verifica nuevamente



```

```{r}
library(fda.usc)
argvals <- as.numeric(as.Date(rownames(matriz_frecuencia)))


library(fda.usc)

# Crear el objeto funcional con fdata
frecuencia_fdata <- fdata(
  t(matriz_frecuencia),        # Matriz transpuesta: 1 observaci칩n x 365 fechas
  argvals = argvals,           # Fechas num칠ricas como puntos de evaluaci칩n
  rangeval = range(argvals)    # Rango de los valores de `argvals`
)

# Verificar el objeto funcional
print(frecuencia_fdata)


```

```{r}
#
# Crear la base funcional B-spline
n_basis <- 25  # Ajusta el n칰mero de bases seg칰n la complejidad deseada
basis <- create.bspline.basis(
  rangeval = range(argvals), 
  nbasis = n_basis
)



```

```{r}
# Graficar los datos funcionales
plot(frecuencia_fdata, 
     main = "Frecuencia de Delitos (Datos Funcionales)", 
     xlab = "Fecha", 
     ylab = "Frecuencia de Delitos")

```


```{r}
# Ajustar el modelo funcional
modelo_funcional <- fregre.basis(
  fdataobj = frecuencia_fdata,  # Objeto funcional creado
  y = y_values,                 # Respuesta (frecuencia de delitos)
  basis.x = basis               # Base funcional para el predictor
)

# Resumen del modelo funcional
summary(modelo_funcional)

```
```{r}
# Verificar la dimensi칩n del objeto funcional
dim(frecuencia_fdata$data)  # Deber칤a ser una matriz con filas como observaciones y columnas como puntos en argvals

# Verificar la longitud del vector y_values
length(y_values)

```


##frecuencia de delitos por tipo y fecha

```{r}
# Agrupar por tipo y fecha, y calcular la frecuencia de delitos
frecuencia_por_tipo <- delitos %>%
  group_by(tipo, fecha) %>%
  summarise(frecuencia = n(), .groups = "drop")

# Aseg칰rate de que las fechas est칠n en formato Date
frecuencia_por_tipo$fecha <- as.Date(frecuencia_por_tipo$fecha, origin = "1899-12-30")

# Definir argvals como las fechas 칰nicas ordenadas
argvals <- as.numeric(as.Date(colnames(matriz_frecuencia)))

# Verifica las dimensiones
dim(matriz_frecuencia)

# Verifica que no haya valores no v치lidos
any(is.na(matriz_frecuencia))  # 쮿ay NA?
any(is.infinite(matriz_frecuencia))  # 쮿ay infinitos?


```



```{r}
library(fda)

# Aseg칰rate de que las columnas representan fechas
fechas <- as.Date(colnames(matriz_frecuencia), format = "%Y-%m-%d")

# Verifica si hay problemas con las fechas
any(is.na(fechas))  # Si es TRUE, hay un problema en el formato de las fechas

# Convierte las fechas a n칰meros
argvals <- as.numeric(fechas)

# Verifica que no haya valores NA
if (any(is.na(argvals))) {
  stop("Las columnas de `matriz_frecuencia` no se pueden convertir en valores num칠ricos.")
}

# Rango de las fechas num칠ricas
rangeval <- range(argvals)

```
```{r}
basis <- create.bspline.basis(rangeval = rangeval, nbasis = nbasis)

```


```{r}
frecuencia_fdata <- Data2fd(
  argvals = argvals,             # Fechas num칠ricas corregidas
  y = t(matriz_frecuencia),      # Matriz transpuesta: tipos x fechas
  basisobj = basis               # Base funcional
)

# Verifica el objeto funcional
print(frecuencia_fdata)

```



```{r}
# Graficar las funciones de cada tipo
plot(frecuencia_fdata, 
     main = "Frecuencia de Delitos por Tipo (Datos Funcionales)", 
     xlab = "Fecha", 
     ylab = "Frecuencia de Delitos",
     col = rainbow(nrow(matriz_frecuencia)),  # Colores para cada tipo
     lwd = 2)  # Grosor de las l칤neas

# Agregar leyenda con los nombres de los tipos
legend("topright", 
       legend = rownames(matriz_frecuencia), 
       col = rainbow(nrow(matriz_frecuencia)), 
       lty = 1, lwd = 2)

```

```{r}
library(fda.usc)

# Definir la variable respuesta (total de delitos por tipo)
respuesta <- rowSums(matriz_frecuencia)

# Ajustar el modelo de regresi칩n funcional
modelo_funcional <- fregre.basis(
  fdataobj = frecuencia_fdata,  # Datos funcionales (predictores)
  y = respuesta,                # Variable respuesta
  basis.x = basis,              # Base funcional para los predictores
  basis.y = basis               # Base funcional para la respuesta
)

# Ver el resumen del modelo
summary(modelo_funcional)

# Inspeccionar el modelo
summary(modelo_funcional)  # Verifica si se ajust칩 correctamente

# Rango de los coeficientes funcionales
# Rango de los coeficientes funcionales
range(modelo_funcional$beta.est$coefs, na.rm = TRUE)

# Revisa las dimensiones y los valores
dim(modelo_funcional$beta.est$coefs)  # Dimensiones
head(modelo_funcional$beta.est$coefs)  # Inspecci칩n de los primeros valores


```
```{r}
# Extraer los valores de los coeficientes
coeficientes <- modelo_funcional$beta.est$coefs[, 1]  # Seleccionar la primera columna

# Graficar los coeficientes manualmente
plot(coeficientes, 
     type = "b",  # L칤nea con puntos
     col = "blue",
     pch = 16,  # Forma de los puntos
     lwd = 2,   # Grosor de la l칤nea
     main = "Coeficientes Funcionales del Modelo", 
     xlab = "칈ndice de la Base B-Spline", 
     ylab = "Valor del Coeficiente",
     ylim = c(0.7, 1.3))  # Ajustar el rango del eje y

```

```{r}
# Graficar el objeto funcional
plot(modelo_funcional$beta.est, 
     main = "Coeficientes Funcionales (Continuos)",
     xlab = "Tiempo", 
     ylab = "Peso de los Tipos de Delitos",
     col = "red", 
     lwd = 2)

```

```{r}
plot(frecuencia_fdata, 
     main = "Frecuencia de Delitos por Tipo (Datos Funcionales)", 
     xlab = "Fecha", 
     ylab = "Frecuencia de Delitos",
     col = rainbow(nrow(matriz_frecuencia)),  # Colores para cada tipo
     lwd = 2)  # Grosor de las l칤neas

# Agregar una leyenda con los tipos
legend("topright", 
       legend = rownames(matriz_frecuencia), 
       col = rainbow(nrow(matriz_frecuencia)), 
       lty = 1, lwd = 2)

```
```{r}
# Verificar valores no v치lidos en la matriz
any(is.na(matriz_frecuencia))  # 쮿ay NA?
any(is.infinite(matriz_frecuencia))  # 쮿ay valores infinitos?

```




```{r}
library(fda.usc)

# Ajustar el modelo de regresi칩n funcional
modelo_funcional <- fregre.basis(
  fdataobj = frecuencia_fdata,    # Datos funcionales
  y = rowSums(matriz_frecuencia), # Suma total de delitos por tipo
  basis.x = basis,                # Base funcional
  basis.y = basis                 # Base funcional para la respuesta
)

# Resumen del modelo
summary(modelo_funcional)

# Coeficientes funcionales
plot(modelo_funcional$beta.est, 
     main = "Coeficientes Funcionales del Modelo", 
     xlab = "Fecha", 
     ylab = "Peso de los Tipos de Delitos")


# Supongamos que `pred_matrix` es una matriz con predictores funcionales (dimensiones deben coincidir)
pred_fdata <- fdata(
  t(matriz_frecuencia),  # Transponemos para que cada fila sea un predictor funcional
  argvals = 1:ncol(matriz_frecuencia),  # Eje X: franjas horarias (o puntos temporales)
  rangeval = c(1, ncol(matriz_frecuencia))  # Rango del eje X
)

# Crear un modelo funcional b치sico con predictores funcionales
modelo <- fregre.basis(
  fdataobj = frecuencia_fdata,  # Objeto funcional de respuesta
  y = frecuencia_delitos_por_dia$frecuencia,  # Variable respuesta asociada
  x = pred_fdata,               # Predictores funcionales
  basis.x = basis_pred,         # Base para los predictores
  basis.y = basis               # Base para la respuesta
)

```

```{r}
plot(frecuencia_fdata, 
     main = "Frecuencia de Delitos por Tipo (Datos Funcionales)", 
     xlab = "Fecha", 
     ylab = "Frecuencia de Delitos",
     col = rainbow(nrow(matriz_frecuencia)),  # Colores para cada tipo
     lwd = 2)  # Grosor de las l칤neas

# Agregar una leyenda con los tipos
legend("topright", 
       legend = rownames(matriz_frecuencia), 
       col = rainbow(nrow(matriz_frecuencia)), 
       lty = 1, lwd = 2)

```



```{r}
# Filtrar las fechas 칰nicas en el mismo orden que en la matriz
fechas_unicas <- unique(frecuencia_categoria$fecha)
fechas_unicas <- fechas_unicas[order(fechas_unicas)]

# Ajustar `argvals` al n칰mero de columnas de la matriz
argvals <- as.numeric(fechas_unicas)

```
```{r}
matriz_frecuencia <- frecuencia_categoria %>%
  pivot_wider(names_from = fecha, values_from = frecuencia, values_fill = 0) %>%
  column_to_rownames(var = "tipo") %>%
  as.matrix()

# Verificar dimensiones
dim(matriz_frecuencia)  # Filas = categor칤as, Columnas = fechas

```

# Frecuencia de delitos agrupado por fecha, pero ver la gr치fica de cada barrio o comuna (depende como salga)

(Hacer)

#3) Frencuencia de delitos agrupados por franja y fecha (24)

```{r}
library(dplyr)

# Agrupar por d칤a y horario, y contar la frecuencia de delitos
delitos_por_dia_horario <- delitos %>%
  group_by(franja, fecha) %>%  # 'franja_horaria' representa los horarios
  summarise(frecuencia = n(), .groups = "drop")

# Aseg칰rate de que las fechas est칠n en formato Date
delitos_por_dia_horario$fecha <- as.Date(delitos_por_dia_horario$fecha, origin = "1899-12-30")
summary(delitos_por_dia_horario)
```

```{r}
library(tibble)
# Crear una matriz con filas como d칤as y columnas como franjas horarias
matriz_frecuencia <- delitos_por_dia_horario %>%
  pivot_wider(names_from = franja, values_from = frecuencia, values_fill = 0) %>%
  column_to_rownames(var = "fecha") %>%
  as.matrix()

# Dimensiones de la matriz
print(dim(matriz_frecuencia))

```
Grafico B-Spline
```{r}
library(fda)
  
  # Rango de horarios (e.g., de 0 a 23 si es en horas)
  range_horarios <- range(as.numeric(colnames(matriz_frecuencia)))
    
    # Crear la base de B-splines
    n_basis <- 25  # Ajusta seg칰n el nivel de suavidad deseado
    basis <- create.bspline.basis(rangeval = range_horarios, nbasis = n_basis)
    
plot(basis,xlab="horarios",ylab="valor base",main="Base B-Spline con 25 nodos",col=1:10 )

```

```{r}

# Transponer la matriz: las filas ser치n las franjas horarias y las columnas las fechas
matriz_frecuencia_transpuesta <- t(matriz_frecuencia)

```

```{r}

library(fda)

# Asegurarte de que las franjas horarias son columnas
matriz_frecuencia_transpuesta <- t(matriz_frecuencia_transpuesta)  # Ahora ser치 365 x 24

# Verificar dimensiones
dim(matriz_frecuencia_transpuesta)  # Debe ser 365 x 24
length(fechas)  # Debe ser 365

# Crear la base de B-splines
range_fechas <- range(fechas)  # Rango de fechas
n_basis <- 25  # Ajusta la cantidad de bases seg칰n la suavidad deseada
basis <- create.bspline.basis(rangeval = range_fechas, nbasis = n_basis)

# Crear el objeto funcional
frecuencia_fd <- Data2fd(
  argvals = fechas,  # Fechas como eje X
  y = matriz_frecuencia_transpuesta,  # Franjas horarias como columnas
  basisobj = basis
)

# Verificar el objeto funcional
print(frecuencia_fd)
summary(frecuencia_fd)

```



```{r}
install.packages("RColorBrewer")
library(RColorBrewer)

fechas_date <- as.Date(fechas, origin = "1970-01-01")
# Crear el gr치fico con dimensiones ampliadas
png("grafico_mejorado_legenda.png", width = 2000, height = 1200, res = 150)  # Resoluci칩n m치s alta

# Ajustar m치rgenes: m치s espacio derecho para la leyenda
par(mar = c(10, 4, 4, 35) + 0.1)  # Aumentar margen derecho para que la leyenda no quede cortada

# Crear el gr치fico principal
plot(frecuencia_fd,
     main = "Frecuencia de delitos por franja horaria",
     xlab = "Fecha",
     ylab = "Frecuencia",
     xaxt = "n",  # Personalizamos el eje X
     col = c(brewer.pal(12, "Set3"), brewer.pal(12, "Paired")),
     lwd = 2)  # Grosor de las l칤neas

# Espaciado de las fechas en el eje X
fechas_etiquetas <- seq(min(fechas_date), max(fechas_date), by = "2 weeks")  # Mostrar cada dos semanas
axis(1,
     at = as.numeric(fechas_etiquetas),  # Espaciado personalizado
     labels = format(fechas_etiquetas, "%d %b"),  # D칤a y mes
     las = 2,  # Rotar las etiquetas
     cex.axis = 0.8)  # Tama침o del texto en el eje X

# Crear una leyenda m치s amplia fuera del 치rea del gr치fico
legend("topright",
       inset = c(-0.7, 0),  # M치s espacio hacia la derecha
       legend = paste0("Franja ", 0:23),
       col = c(brewer.pal(12, "Set3"), brewer.pal(12, "Paired")),
       lty = 1,
       lwd = 2,  # Grosor de las l칤neas
       ncol = 2,  # Dividir la leyenda en dos columnas
       cex = 1.2,  # Tama침o del texto m치s grande
       xpd = TRUE)  # Permitir que la leyenda est칠 fuera del 치rea de dibujo

# Guardar y cerrar el archivo PNG
dev.off()

# Verificar que el archivo fue creado
browseURL("grafico_mejorado_legenda.png")

```




##Comparo sin fda
```{r}
# Asegurarte de que tienes las librer칤as necesarias
library(ggplot2)

# Convertir los datos en formato largo para ggplot
datos_crudos <- as.data.frame(matriz_frecuencia)
datos_crudos$Fecha <- fechas_date  # Agregar fechas como columna
datos_largos <- tidyr::pivot_longer(
  datos_crudos,
  cols = -Fecha,
  names_to = "Franja_Horaria",
  values_to = "Frecuencia"
)

# Generar el gr치fico crudo
grafico_crudo <- ggplot(datos_largos, aes(x = Fecha, y = Frecuencia, color = Franja_Horaria)) +
  geom_line(alpha = 0.8, size = 0.5) +  # L칤neas m치s delgadas
  scale_color_manual(values = scales::hue_pal()(24)) +  # 24 colores bien diferenciados
  labs(
    title = "Frecuencia de delitos por franja horaria (Datos crudos)",
    x = "Fecha",
    y = "Frecuencia",
    color = "Franja Horaria"
  ) +
  theme_minimal(base_size = 14) +  # Tema minimalista
  theme(
    legend.position = "right",
    legend.text = element_text(size = 10),
    axis.text.x = element_text(angle = 45, hjust = 1)  # Rotar etiquetas del eje X
  )

# Mostrar el gr치fico
print(grafico_crudo)


```

##Grafico comparativo entre fda y sin fda

```{r}
# Librer칤as necesarias
install.packages("RColorBrewer")
install.packages("png")
library(RColorBrewer)
library(ggplot2)
library(grid)
library(gridExtra)
library(png)

# Crear el gr치fico sin FDA
png("grafico_sin_fda_separado.png", width = 1600, height = 900, res = 150)
ggplot(datos_largos, aes(x = Fecha, y = Frecuencia, color = Franja_Horaria)) +
  geom_line(alpha = 0.8, size = 0.5) +
  scale_color_manual(values = scales::hue_pal()(24)) +
  labs(
    title = "Frecuencia de delitos por franja horaria (Sin FDA)",
    x = "Fecha",
    y = "Frecuencia",
    color = "Franja Horaria"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "right",
    legend.text = element_text(size = 8),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
dev.off()

# Crear el gr치fico con FDA
png("grafico_con_fda_separado.png", width = 1600, height = 900, res = 150)
par(mar = c(10, 4, 4, 35) + 0.1)  # Ajustar m치rgenes
plot(frecuencia_fd,
     main = "Frecuencia de delitos por franja horaria (Con FDA)",
     xlab = "Fecha",
     ylab = "Frecuencia",
     xaxt = "n",
     col = c(brewer.pal(12, "Set3"), brewer.pal(12, "Paired")),
     lwd = 2)  # Grosor de las l칤neas
fechas_etiquetas <- seq(min(fechas_date), max(fechas_date), by = "1 month")
axis(1,
     at = as.numeric(fechas_etiquetas),
     labels = format(fechas_etiquetas, "%b %Y"),
     las = 2,
     cex.axis = 0.8)
legend("topright",
       inset = c(-0.5, 0),
       legend = paste0("Franja ", 0:23),
       col = c(brewer.pal(12, "Set3"), brewer.pal(12, "Paired")),
       lty = 1,
       lwd = 2,
       ncol = 2,
       cex = 0.8,
       xpd = TRUE)
dev.off()

# Cargar ambas im치genes y combinarlas
grafico_sin_fda <- rasterGrob(readPNG("grafico_sin_fda_separado.png"), interpolate = TRUE)
grafico_con_fda <- rasterGrob(readPNG("grafico_con_fda_separado.png"), interpolate = TRUE)

# Guardar gr치fico combinado
png("comparacion_graficos_final.png", width = 3200, height = 900, res = 150)
grid.arrange(
  gridExtra::arrangeGrob(grafico_con_fda, top = "Con FDA"),
  gridExtra::arrangeGrob(grafico_sin_fda, top = "Sin FDA"),
  ncol = 2
)
dev.off()

# Mostrar el archivo final
browseURL("comparacion_graficos_final.png")




```
##Grafico la derivada
```{r}
install.packages("fda.usc")
library(fda.usc)

# Supongamos que el rango del eje X corresponde a d칤as desde una fecha base
fecha_base <- as.Date("2023-01-01")
x_vals <- seq(from = 19400, to = 19700, length.out = 10)

frecuencia_fd_deriv <- fdata.deriv(frecuencia_fd)

# Convertir valores a fechas
fechas <- fecha_base + (x_vals - min(x_vals))  # Ajusta seg칰n tu dato base

# Volver a plotear con fechas en el eje X
plot(frecuencia_fd_deriv, main = "Derivada de la Frecuencia de Delitos", xaxt = "n")
axis(1, at = x_vals, labels = format(fechas, "%Y-%m-%d"))  # Mostrar fechas


```

##Segunda derivada
```{r}
# Calcular la segunda derivada del objeto funcional (frecuencia_fd)
segunda_derivada <- deriv.fd(frecuencia_fd, deriv = 2)

# Verificar el objeto segunda_derivada
print(segunda_derivada)
```

```{r}
# Crear el gr치fico de la segunda derivada sin eje X predeterminado
plot(segunda_derivada, 
     main = "Segunda Derivada de la Frecuencia de Delitos",
     xlab = "t", 
     ylab = "d(X(t))/dt", 
     col = rainbow(24),  # Colores para las franjas horarias
     lwd = 2,            # Grosor de las l칤neas
     xaxt = "n")         # Ocultar etiquetas predeterminadas del eje X

# Ajustar los valores del eje X (modificar el rango seg칰n tus datos)
x_vals <- seq(from = 19400, to = 19700, length.out = 10)  # Ajusta el rango aqu칤
fecha_base <- as.Date("2023-01-01")  # Ajustar fecha base si aplica
fechas <- fecha_base + (x_vals - min(x_vals))  # Convertir 칤ndices a fechas

# Agregar etiquetas al eje X
axis(1, at = x_vals, labels = format(fechas, "%Y-%m-%d"))  # Etiquetas en formato de fecha


```
<br>

Si quieres analizar incrementos y decrementos generales, la primera derivada es m치s 칰til.
Si quieres identificar transiciones, picos o cambios en la din치mica de los datos, la segunda derivada proporciona m치s detalles.


Este gr치fico muestra la segunda derivada de la frecuencia de delitos respecto al tiempo, y nos permite analizar:

Cambios en la concavidad:

Cuando la segunda derivada cruza el eje 
洧녽
=
0
y=0, indica un cambio en la curvatura de la frecuencia de delitos:
De c칩ncavo a convexo (o viceversa).
Estos puntos son cr칤ticos para identificar patrones de aceleraci칩n o desaceleraci칩n en la frecuencia de delitos.
Valores positivos:

La frecuencia de delitos est치 acelerando su aumento (creciendo m치s r치pido) o desacelerando su disminuci칩n (la disminuci칩n se suaviza).
Valores negativos:

La frecuencia de delitos est치 desacelerando su aumento (creciendo m치s lentamente) o acelerando su disminuci칩n (bajando m치s r치pido).
Regiones planas o cercanas a 0:

Indican que el cambio en la velocidad (aceleraci칩n) es peque침o o constante en ese rango.
En este gr치fico:

Observamos que hay fluctuaciones importantes al inicio (en torno a 19400) y al final (cerca de 19700).
Esto puede indicar que en esos puntos hay eventos significativos o transiciones importantes en las franjas horarias o patrones temporales.
<br>







##Freuencia de delitos agrupados por fecha

```{r}
# Instalar y cargar los paquetes necesarios
if (!require("fda.usc")) install.packages("fda.usc")
library(fda.usc)
library(dplyr)

# 1. Agrupar y procesar los datos
frecuencia_delitos_por_dia <- delitos %>%
  group_by(fecha) %>%
  summarise(frecuencia = n(), .groups = "drop")

# Asegurar que las fechas est칠n en formato Date y luego convertirlas a num칠ricas
frecuencia_delitos_por_dia$fecha <- as.Date(frecuencia_delitos_por_dia$fecha)
frecuencia_delitos_por_dia$fecha_num <- as.numeric(frecuencia_delitos_por_dia$fecha)

# Crear el rango de fechas (argvals)
argvals <- frecuencia_delitos_por_dia$fecha_num

# Crear la matriz de observaciones
# Cada observaci칩n es una fila (n칰mero de fechas observadas)
y_matrix <- matrix(frecuencia_delitos_por_dia$frecuencia, 
                   nrow = length(frecuencia_delitos_por_dia$frecuencia), 
                   ncol = 1)

# Crear el objeto funcional `fdata`
frecuencia_fdata <- fdata(y_matrix, argvals = argvals)

# Verificar dimensiones del objeto funcional
print(dim(frecuencia_fdata$data))  # Debe coincidir con las fechas observadas

# 2. Crear el vector de respuesta y predictor
y <- frecuencia_delitos_por_dia$frecuencia  # Variable respuesta
x <- data.frame(intercepto = 1)            # Predictor constante (intercepto)

# 3. Ajustar el modelo funcional de regresi칩n
modelo_fda <- fregre.basis(fdataobj = frecuencia_fdata, y = y, x = x)

# 4. Resumen del modelo
summary(modelo_fda)

# 5. Graficar los valores ajustados y observados
plot(argvals, modelo_fda$fitted.values, type = "l", col = "blue", lwd = 2,
     main = "Modelo FDA: Frecuencia de Delitos",
     xlab = "Fecha Num칠rica",
     ylab = "Frecuencia Ajustada")
points(argvals, y, col = "red", pch = 16)
legend("topright", legend = c("Ajustada", "Real"), col = c("blue", "red"), lty = 1, lwd = 2, pch = c(NA, 16))
topright", legend = c("Ajustada", "Real"), col = c("blue", "red"), lty = 1, lwd = 2, pch = c(NA, 16))



```





