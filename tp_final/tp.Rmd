---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code.

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*.

```{r}
install.packages("openxlsx")
# Instalar el paquete si no está instalado
if (!require("dplyr")) install.packages("dplyr")
# Cargar el paquete
library(dplyr)
```

# Trabajo Práctico Final

# 1) Fuente de datos

## Carga el dataset

.

```{r}
library(openxlsx)
delitos <- read.xlsx("/Users/bquinonez/Downloads/delitos_2023.xlsx")
delitos
```

```{r}
summary(delitos)

```

```{r}
dim(delitos)
```

# 2) Preprocesamiento

## Verificación de nulos

```{r}
colSums(is.na(delitos))
```

Tipos de Delitos

```{r}
cantidad_valores_unicos <- (unique(delitos$tipo))
print(cantidad_valores_unicos)
```

Subtipos de delitos

```{r}
conteo_por_tipo <- table(delitos$tipo)
print(conteo_por_tipo)
```

```{r}
cantidad_valores_unicos <- (unique(delitos$subtipo))
print(cantidad_valores_unicos)
conteo_por_subtipo <- table(delitos$subtipo)
print(conteo_por_subtipo)
```

## Creación de variables

Agregamos la columna de franja horaria

```{r}
#Genero la columna franja(horaria)
delitos <- delitos %>%
  mutate(
    franja_horaria = case_when(
      franja >= 6 & franja < 12 ~ "Mañana",
      franja >= 12 & franja < 18 ~ "Tarde",
      franja >= 18 & franja < 24 ~ "Noche",
      franja >= 0 & franja < 6  ~ "Madrugada",
      TRUE ~ "Desconocido" # Para casos fuera de rango 
    )
  )
delitos
```

Agregamos una columna que indica si es fin de semana o día de semana

```{r}
delitos$tipo_dia <- ifelse(delitos$dia %in% c("SAB", "DOM"),
                                             "Fin de semana", "Día de semana")
delitos
```

Agregamos una columna que indica la estación del año

```{r}
# Crear columna 'estacion' basada en el mes
delitos <- delitos %>%
  mutate(
    estacion = case_when(
      mes %in% c("diciembre", "enero", "febrero") ~ "Verano",
      mes %in% c("marzo", "abril", "mayo")       ~ "Otoño",
      mes %in% c("junio", "julio", "agosto")     ~ "Invierno",
      mes %in% c("septiembre", "octubre", "noviembre") ~ "Primavera",
      TRUE ~ "Desconocido" # Para casos no esperados
    )
  )
delitos
```

## Transformación de variables categóricas

Transformamos todos los caracteres a numéricos

```{r}

# Convertir todas las variables categóricas (character o factor) a numéricas
delitos <- delitos %>%
  mutate(across(
    .cols = where(is.character) & !all_of(c("longitud", "latitud")), 
    .fns = ~ as.numeric(as.factor(.))
  )) %>%
  mutate(across(
    .cols = where(is.factor) & !all_of(c("longitud", "latitud")), 
    .fns = ~ as.numeric(.)
  ))

# Verificar la estructura después de la conversión
delitos

```

Conversión de coordenas a númericas

```{r}
# Convertir longitud y latitud a numéricas y escalarlas correctamente
delitos <- delitos %>%
  mutate(
    longitud = as.numeric(longitud) / 1e6,  # Escalar dividiendo entre 10^6
    latitud = as.numeric(latitud) / 1e6    # Escalar dividiendo entre 10^6
  )

# Verificar las primeras filas para confirmar
head(delitos[c("longitud", "latitud")])
```

Eliminación de Nulos (Pero tiene que ser transformación de nulos para no perder datos, lo hacemos después)

```{r}
delitos <- na.omit(delitos)
dim(delitos)
```

# 3) Aplicación de FDA

## Creamos la variable dependiente

```{r}
# Instalar las librerías necesarias
if (!require("refund")) install.packages("refund")
if (!require("dplyr")) install.packages("dplyr")

# Cargar las librerías
library(refund)
library(dplyr)

# Preparar el dataset
# Agrupar por fecha y calcular la frecuencia diaria de delitos
delitos_agrupados <- delitos %>%
  group_by(fecha) %>%
  summarise(
    frecuencia_delitos = sum(cantidad),  # Nueva variable respuesta
    tipo_promedio = mean(tipo, na.rm = TRUE),  # Promedio de tipo por día
    franja_horaria_promedio = mean(franja_horaria, na.rm = TRUE)  # Promedio de franja horaria
  )

# Eliminar filas con valores faltantes
delitos_agrupados <- delitos_agrupados[complete.cases(delitos_agrupados), ]

# Crear la respuesta (frecuencia de delitos por día)
Y <- delitos_agrupados$frecuencia_delitos

# Crear una matriz funcional para 'tipo'
n_puntos <- 10  # Número de puntos funcionales
tipo_matrix <- matrix(rep(delitos_agrupados$tipo_promedio, each = n_puntos), 
                      nrow = nrow(delitos_agrupados), 
                      ncol = n_puntos)

# Crear una matriz funcional para 'franja_horaria'
franja_horaria_matrix <- matrix(rep(delitos_agrupados$franja_horaria_promedio, each = n_puntos), 
                                nrow = nrow(delitos_agrupados), 
                                ncol = n_puntos)

# Verificar dimensiones
print(length(Y))  # Longitud de Y
print(dim(tipo_matrix))  # Dimensiones de tipo_matrix
print(dim(franja_horaria_matrix))  # Dimensiones de franja_horaria_matrix

# Ajustar el modelo funcional con 'tipo' como predictora funcional
modelo_refund_tipo <- pfr(
  Y ~ lf(tipo_matrix, bs = "ps"),  # lf() para predictoras funcionales
  data = delitos_agrupados
)

# Resumen del modelo
summary(modelo_refund_tipo)

# Visualizar el efecto funcional
plot(modelo_refund_tipo, main = "Efecto Funcional de Tipo de Delito", 
     xlab = "Dominio (Puntos Funcionales)", ylab = "Efecto")

# Ajustar un modelo funcional con múltiples predictoras funcionales
modelo_refund_mixto <- pfr(
  Y ~ lf(tipo_matrix, bs = "ps") + lf(franja_horaria_matrix, bs = "ps"),
  data = delitos_agrupados
)

# Resumen del modelo mixto
summary(modelo_refund_mixto)

# Visualizar los efectos funcionales de las predictoras
plot(modelo_refund_mixto, main = "Efectos Funcionales de las Predictoras", pages = 1)

# Generar predicciones del modelo mixto
# Predicciones del modelo
predicciones <- predict(modelo_refund_mixto)

# Valores reales (frecuencia de delitos)
valores_reales <- Y

# Calcular MAE
mae <- mean(abs(valores_reales - predicciones))

# Calcular MSE
mse <- mean((valores_reales - predicciones)^2)

# Calcular RMSE
rmse <- sqrt(mse)

# Calcular R^2
sse <- sum((valores_reales - predicciones)^2)  # Suma de errores al cuadrado
sst <- sum((valores_reales - mean(valores_reales))^2)  # Suma total de cuadrados
r2 <- 1 - (sse / sst)

# Mostrar las métricas
cat("MAE:", mae, "\n")
cat("MSE:", mse, "\n")
cat("RMSE:", rmse, "\n")
cat("R^2:", r2, "\n")

# Graficar predicciones vs valores reales
plot(Y, predicciones, main = "Predicciones vs Valores Reales (Modelo Mixto)",
     xlab = "Valores Reales", ylab = "Predicciones", col = "blue")
abline(0, 1, col = "red")



```

## Crear la Base Funcional

```{r}
# Verificar el tipo de Y
# Verificar la clase de las matrices
print(class(uso_arma_matrix))  # Debe ser "matrix"
print(class(franja_horaria_matrix))  # Debe ser "matrix"

# Verificar valores faltantes
anyNA(uso_arma_matrix)
anyNA(franja_horaria_matrix)

```

## Incorporar Variables Predictoras (Opcional)

```{r}
# Crear una lista de predictoras funcionales
predictoras_funcionales <- list(
  uso_arma = uso_arma_fd,
  franja_horaria = franja_horaria_fd
)

# Ajustar el modelo funcional
modelo_funcional <- fregre.basis(
  y = frecuencia_fd,  # Respuesta funcional
  x = predictoras_funcionales  # Predictoras funcionales
)

# Resumen del modelo
summary(modelo_funcional)

# Predicciones
predicciones <- predict(modelo_funcional)

# Graficar los resultados
plot(frecuencia_fd, main = "Frecuencia de Delitos (Curva Real vs Ajustada)")
lines(predicciones, col = "red", lwd = 2)
legend("topright", legend = c("Real", "Predicción"), col = c("black", "red"), lty = c(1, 1))



```

```{r}
# Crear una base de B-splines
n_basis <- 15  # Número de funciones base
base_bspline <- create.bspline.basis(
  rangeval = range(delitos_por_dia$fecha),
  nbasis = n_basis
)

# Convertir el objeto fdata a fd usando la base creada
frecuencia_fd <- fdata2fd(frecuencia_fdata, type.basis = "bspline", nbasis = n_basis)
uso_arma_fd <- fdata2fd(uso_arma_fdata, type.basis = "bspline", nbasis = n_basis)
franja_horaria_fd <- fdata2fd(franja_horaria_fdata, type.basis = "bspline", nbasis = n_basis)

# Verificar el objeto funcional creado
print(frecuencia_fd)

```

```{r}
# Crear un listado de predictoras funcionales
predictoras_funcionales <- list(
  uso_arma = uso_arma_fd,
  franja_horaria = franja_horaria_fd
)

# Ajustar el modelo funcional
modelo_funcional <- fregre.basis(frecuencia_fd, x = predictoras_funcionales, basis = base_bspline)

# Resumen del modelo
summary(modelo_funcional)

# Predicciones del modelo
predicciones <- predict(modelo_funcional)

```

```{r}
# Agregar predictoras escalares
predictoras_escalares <- delitos_agrupados[, c("tipo", "subtipo")]  # Ejemplo de predictoras escalares

# Modelo funcional con escalares
modelo_mixto <- fregre.gsam(
  y = frecuencia_fd,
  x = list(fdata = predictoras_funcionales, sc = predictoras_escalares)
)

# Resumen del modelo mixto
summary(modelo_mixto)


```

```{r}
# Graficar la curva observada (frecuencia real) vs. la predicción del modelo
plot(frecuencia_fd, col = "blue", lwd = 2, main = "Curvas Observadas vs. Predichas")
lines(modelo_fda$yhatfd, col = "red", lwd = 2)
legend("topright", legend = c("Observada", "Predicha"), col = c("blue", "red"), lwd = 2)

```
